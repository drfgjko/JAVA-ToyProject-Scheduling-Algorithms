# 课程设计报告
## 说明
- **以下内容仅为原课设报告PDF的简易版归纳**
- 程序使用**jsmooth**进行打包
- 感谢打包教程，尤其是关于jre的部分
> [使用jsmooth将jar文件转换成可在无java的环境中运行的exe文件](https://blog.csdn.net/m0_37154839/article/details/89396939?spm=1001.2014.3001.5506)
### 依赖说明

请确保使用以下环境，并将**jre与exe文件置于同一文件夹下（两者为兄弟关系）**：

- **Framework**: v5.0.3，可能包含在 JRE 8、JDK 8 和 OpenJDK 8 中。

## 目录

1. [概述](#1-概述)
   1. [设计主要完成的任务](#11-设计主要完成的任务)
   2. [解决的主要问题](#12-解决的主要问题)
   3. [设计的基本概念和原理](#13-设计的基本概念和原理)
      1. [算法基本原理](#131-算法基本原理)
      2. [算法基本功能](#132-算法基本功能)
      3. [数据流图](#133-数据流图)
2. [总体设计](#2-总体设计)
   1. [实现的方法](#21-实现的方法)
   2. [主要技术路线](#22-主要技术路线)
   3. [算法总体结构](#23-算法总体结构)
      1. [算法主要组成部分](#231-算法主要组成部分)
      2. [算法内部流程图](#232-算法内部流程图)
   4. [数据结构](#24-数据结构)
   5. [模块关系](#25-模块关系)
   6. [总体流程](#26-总体流程)
3. [详细设计](#3-详细设计)
   1. [使用的主要控件](#31-使用的主要控件)
   2. [模块内部流程](#32-模块内部流程)
   3. [算法步骤](#33-算法步骤)
      1. [FCFS](#331-fcfs)
      2. [非抢占SJF](#332-非抢占sjf)
      3. [优先级](#333-优先级)
      4. [时间片调度](#334-时间片调度)
   4. [函数说明](#34-函数说明)
      1. [Scheduler模块](#341-scheduler模块)
      2. [ProcessUtils模块](#342-processutils模块)
      3. [GUI模块](#343-gui模块)
      4. [Process模块](#344-process模块)
   5. [简要的使用说明](#35-简要的使用说明)
   6. [完成的情况](#36-完成的情况)
   7. [测试与数据分析](#37-测试与数据分析)
      1. [测试](#371-测试)
      2. [数据分析](#372-数据分析)
   8. [结果分析](#38-结果分析)
4. [总结](#4-总结)
   1. [特色及不足](#41-特色及不足)
   2. [经验](#42-经验)
   3. [教训](#43-教训)
   4. [感受](#44-感受)
5. [参考文献](#5-参考文献)

## 1. 概述

### 1.1 设计主要完成的任务

1. 随机设置参数，生成调度所需的进程（后续可手动修改参数）
2. 实现FCFS（先来先服务）、非抢占SJF（最短作业优先）、优先权调度、RR（轮转调度）调度算法
3. 利用CPU调度算法对模拟进程进行调度，输出调度结果
4. 计算平均周转时间和平均等待时间，输出算法评价指标

### 1.2 解决的主要问题

1. 实现FCFS、非抢占SJF、优先权调度、RR调度算法
2. 算法评价指标计算
3. 实现可视化界面

### 1.3 设计的基本概念和原理

#### 1.3.1 算法基本原理

根据《计算机操作系统》P79-P82，了解算法基本原理：

1. **先来先服务（FCFS）调度算法**：每次调度选择最先进入队列的进程。
2. **短作业优先（SJF）调度算法**：选择估计运行时间最短的进程。
3. **优先级调度算法**：选择具有最高优先级的进程运行。
4. **轮转调度（RR）算法**：进程按FCFS排成队列，定期激活调度程序。

#### 1.3.2 算法基本功能

1. **FCFS算法**：选择最先进入的进程运行。
2. **非抢占SJF调度算法**：选择服务时间最短的进程运行。
3. **优先权调度算法**：选择优先级最高的进程运行。
4. **RR调度算法**：为队首进程分配时间片。

#### 1.3.3 数据流图

模拟进程调度系统的顶层及0层数据流图如下。

（图 1 系统的顶层及0层数据流图）

## 2. 总体设计

### 2.1 实现的方法

- **编程语言**：JAVA
- **可视化界面**：Swing构建图形界面
- **进程调度**：List和Queue存储进程
- **调度结果表现形式**：参考《计算机操作系统》P82

（图 2 不同时间片下进程的周转时间）

### 2.2 主要技术路线

1. 进程模型设计及实现。
2. 调度算法的实现。
3. 算法性能评估的实现。
4. 模拟进程调度的实现步骤。
5. 用户界面与交互设计。

### 2.3 算法总体结构

#### 2.3.1 算法主要组成部分

- **进程队列**：存储待执行的进程。
- **就绪队列**：存储已到达的进程。

#### 2.3.2 算法内部流程图

（图 3 算法流程图-1）

（图 4 算法流程图-2）

### 2.4 数据结构

1. **进程类**：包含基本信息和调度所需的属性。
2. **List**：存储模拟进程和就绪队列。
3. **Queue**：存储RR调度算法的就绪队列。

### 2.5 模块关系

- **GUI**：用户交互的界面实现。
- **Scheduler**：进程调度的算法实现。
- **Process**：进程定义。
- **ProcessUtils**：与进程相关的计算工具方法。

### 2.6 总体流程

模拟进程调度系统的流程图如下。

（图 6 总体流程图）

## 3. 详细设计

### 3.1 使用的主要控件

- **输入控件**：JComboBox, JTextField, JButton
- **显示控件**：JTable, JTextArea, JLabel
- **容器控件**：JPanel, JScrollPane
- **布局管理器**：FlowLayout, BoxLayout
- **对话框**：JoptionPane
- **数据模型**：DefaultTableModel

### 3.2 模块内部流程

Process模块定义了模拟进程。GUI模块的内部流程图如下图所示。

（图 7 GUI模块内部流程图）

### 3.3 算法步骤

#### 3.3.1 FCFS

1. 将进程按照到达时间进行排序。
2. 初始化当前时间为0。
3. 主调度循环，更新就绪队列。
4. 对就绪队列执行调度，更新进程信息。

#### 3.3.2 非抢占SJF

1. 将进程按照到达时间进行排序。
2. 初始化当前时间为0。
3. 主调度循环，更新就绪队列。
4. 对就绪队列执行调度，更新进程信息。

#### 3.3.3 优先级

1. 将进程按照到达时间进行排序。
2. 初始化当前时间为0。
3. 主调度循环，更新就绪队列。
4. 对就绪队列执行调度，更新进程信息。

#### 3.3.4 时间片调度

1. 将进程按照到达时间进行排序。
2. 初始化当前时间为0。
3. 主调度循环，更新就绪队列。
4. 对就绪队列执行调度。

### 3.4 函数说明

#### 3.4.1 Scheduler模块

- `schedule(List<Process> processes, Comparator<Process> comparator)`：通用的调度函数。

#### 3.4.2 ProcessUtils模块

- `getAverageTurnaroundTime(List<Process> processes)`：计算平均周转时间。

#### 3.4.3 GUI模块

- `GUI()`：控件初始化及面板设置。

#### 3.4.4 Process模块

模拟进程定义如下。

### 3.5 简要的使用说明

1. 选择进程数。
2. 选择调度算法。
3. 输入时间片（仅RR算法）。
4. 生成进程。
5. 进程调度。
6. 编辑进程。
7. 保存修改。
8. 算法评价。

### 3.6 完成的情况

为用户提供了一个可视化界面，可选择进程数量后随机生成对应进程，后续可修改保存进程信息。

### 3.7 测试与数据分析

#### 3.7.1 测试

基本功能测试结果如下。

（图 8 功能测试）

#### 3.7.2 数据分析

不同调度算法的调度结果及算法评价指标。

（表格 1 算法评价指标）

### 3.8 结果分析

1. FCFS是一种最简单的调度算法。
2. 非抢占SJF调度策略最优。
3. 优先级调度根据优先级调度。
4. RR调度算法中，时间片大小对性能有影响。

## 4. 总结

### 4.1 特色及不足

具有简易的可视化界面，基础逻辑简单，系统可扩充性较好。

### 4.2 经验

前期准备是重要的，完成总体设计工作。

### 4.3 教训

设计没有全面考虑，缺少进程状态管理。

### 4.4 感受

实现了模拟进程调度算法，对课程内容有了更深刻的理解。


## 5. 参考文献

1. [Jimoshalengzhou. (2024). Java抢占式和非抢占式 抢占式sjf算法. 51CTO博客.](https：//blog.51cto.com/u_39037/10051829)
2. [CSDN. (2024). Java开发的进程调度模拟器完整指南.](https://blog.csdn.net/weixin_33622085/article/details/143471700)
3. **汤小丹, 王红玲, 姜华, 汤子瀛. (2021). 计算机操作系统（慕课版）.**
